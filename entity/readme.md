# entity
按照DDD设计原理,实体（Entity）是在相同限界上下文中具有唯一标识的领域模型，可变，通过标识判断同一性
限界上下文: 映射关系像一颗树,有根节点,节点可以有任意多个子节点,叶子节点无子节点,实现节点的增、删、改(子节点移动)、查等功能
实体的唯一标识:nodeId是树节点模型实体的唯一标识,任何两个nodeId不同的node 实例,都表示不同的实体.
可变: 树节点模型的所有属性(nodeId、parentId、depth、path)在发生某些行为时都可能发生变化,label属性虽然在行为过程中不会变,但是会影响行为(目前设定lable=leaf时,不能增加子节点,关于这个业务规则是否有更好的变通实现方式,可以探讨)
 新增行为: 新增节点,会修改入参的depth、path属性
 移动节点行为: 移动节点会修改当前节点的 parentId、depth、path属性以及所有子节点的depth、path属性
 查询行为: 查询节点,不会修改属性,但是在新增、移动节点时,需要查询行为,查询行为可能觉得新增、移动行为对属性修改的结果.另外查询行为有自己内部逻辑(查询子树),所以也封装到entity中
 删除行为: 删除节点,并不会改变nodeId、parentId、depth、path中的任何属性,删除行为导致的结果比较简洁(删除字段标记即可),将删除属性移交给repository实现更具扩展性(数据表可以定义任何字段为删除字段)
 实体 access repository : repository 强IO操作,具有强副作用(相同输入,根据外部设备的不同——如网路、数据库不可用,会得到不同的结果)entity模型通过构造函数传入repository interface 实现依赖倒置效果,并且内置一个简洁的sql 实现.(后续可能实现高扩展)
 entity的创建: 统一采用 NewNodeEntity 工厂创建,nodeEntity对包外不可见,包外限定只能通过NewNodeEntity方法创建
 entity 的聚合: 包内暂时不提供聚合,由于nodeEntity 包外不可见,无法在包外聚合,entity 的聚合需要再思考实现方式,要么对外开放nodeEntity 实体,要么包内实现通用聚合
 实体发布领域事件: 暂未实现,后续需要定义领域事件并对外发布,对外发布事件,预计也会采用接口方式实现依赖倒置
 实体关联值对象: 暂未实现值对象,目前考虑值对象由外部灵活实现(和entity的聚合策略矛盾),后续有通用的值对象解决方案时,可以考虑包内实现
