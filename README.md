# 树形结构模型
树形结构在实际编程中应用广泛，如 省市区、组织架构、代理关系、目录结构、分类、分组等。
基于关系型数据结构存储树状模型的设计主要有邻接列表模式、物化路径、左右值编码、闭包表等几种方案，其中通用的是邻接列表模式、物化路径。
设计方案比较明确和通用，每个设计方案对应的表结构设计固定，对表操作也是比较通用的，针对这部分的操作逻辑也是比较固定的，所以本模型基于邻接列表模式和物化路径的结合，实现通用操作，减少重复开发工作，另外尽可能做到完备，不断迭代优化模型，提升模型的实用性
为了方便和其它项目结合,保持模块的通用性、可扩展性、最小约束外部系统特性，本模型仅提供树模型的常规操作行为逻辑的实现，不涉及数据的存储
## 功能列表
1. 新增节点，新增行为通过传入nodeId和parentId，返回 节点的path和depth 数据，使用方决定如何持久化数据
2. 根据节点ID获取节点(该接口为非重要接口，由于对外依赖的repository interface中已经要求实现获取节点，所以顺便封装提供)
3. 获取所有父节点(可以包含自己)。根据传入的nodeId，依赖repository interface 获取节点的path,得到所有父节点的nodeId，再批量查询父节点
4. 获取指定深度的子树。根据传入的nodeId,调用RepositoryInterface.GetNode获取节点的path,构造sql path 字段前缀pathPrefix，调用RepositoryInterface.GetAllByPathPrefix 获取数据
5. 移动节点。根据入参nodeId、newParentId找到当前节点和所有子节点以及新的父节点，计算修改当前节点的parentId字段，重新设置当前节点和子节点的path并重新计算depth,返回当前节点和字节点的path和depth(当前节点的parentId)供调用方持久化数据
6. 删除节点。根据传入的nodeId 找到所有子节点，返回需要删除的节点ID列表，供调用方持久化数据
## 辅助工具列表
1. 二维行列数据（数据库格式）转树状模型
2. 根据全量数据的节点ID、父节点ID 给全量数据增加path、depth 属性（批量导入数据时有用）
3. 统计树的各个节点子节点数目

## 对外约束和依赖
使用此库，必须实现接口 RepositoryInterface 为了提升通用新，模型对于写入数据，只提供计算的数据值，不约束外部如何存储。因此RepositoryInterface 只约束必要的获取数据接口.(只约束在计算数据时必须获取数据接口)

## 扩展
分层聚合其实也类似于树状结构，设计中将融合分层聚合的模型，以电商的商品分类为例，某个商品按商品管理分类，属于手机，按活动分类可以属于热门商品，基于这种多维度分类，模型提供树交叉功能
## 参考资料
https://www.cnblogs.com/goloving/p/13570067.html

按照DDD设计原理,实体（Entity）是在相同限界上下文中具有唯一标识的领域模型，可变，通过标识判断同一性
限界上下文: 映射关系像一颗树,有根节点,节点可以有任意多个子节点,叶子节点无子节点,实现节点的增、删、改(子节点移动)、查等功能
实体的唯一标识:nodeId是树节点模型实体的唯一标识,任何两个nodeId不同的node 实例,都表示不同的实体.
可变: 树节点模型的所有属性(nodeId、parentId、depth、path)在发生某些行为时都可能发生变化,label属性虽然在行为过程中不会变,但是会影响行为(目前设定lable=leaf时,不能增加子节点,关于这个业务规则是否有更好的变通实现方式,可以探讨)
 新增行为: 新增节点,会修改入参的depth、path属性
 移动节点行为: 移动节点会修改当前节点的 parentId、depth、path属性以及所有子节点的depth、path属性
 查询行为: 查询节点,不会修改属性,但是在新增、移动节点时,需要查询行为,查询行为可能觉得新增、移动行为对属性修改的结果.另外查询行为有自己内部逻辑(查询子树),所以也封装到entity中
 删除行为: 删除节点,并不会改变nodeId、parentId、depth、path中的任何属性,删除行为导致的结果比较简洁(删除字段标记即可),将删除属性移交给repository实现更具扩展性(数据表可以定义任何字段为删除字段)
 实体 access repository : repository 强IO操作,具有强副作用(相同输入,根据外部设备的不同——如网路、数据库不可用,会得到不同的结果)entity模型通过构造函数传入repository interface 实现依赖倒置效果,并且值依赖repository 的查询接口，entity 对写入数据不直接依赖repository，而是返回修改后的数据，从而对外部实现零约束，提升扩展性
 entity的创建: 统一采用 NewNodeEntity 工厂创建,nodeEntity对包外不可见,包外限定只能通过NewNodeEntity方法创建
 entity 的聚合: 包内不提供聚合，因为值对象不固定，聚合对象属性不固定，所以entity 聚合交由外部自主实现，这得益于entity对外部数据结构的零约束特性
 实体发布领域事件: 暂未实现,如果后续需要，则可以在包内实现生产领域事件，交由外部发布
 实体关联值对象: 不计划实现，实体可以和任意结构值对象组合生成聚合跟满足业务，因此无需在包内实现值对象关联


## 使用
1. 外部实现 RepositoryInterface 接口
2. 调用 NewNodeEntity 生成实体，调用对应方法即可